# Simple calculator
function calc() {
    local result="";
    result="$(printf "scale=10;$*\n" | bc --mathlib | tr -d '\\\n')";
    #                       └─ default (when `--mathlib` is used) is 20
    #
    if [[ "$result" == *.* ]]; then
        # improve the output for decimal numbers
        printf "$result" |
        sed -e 's/^\./0./'        `# add "0" for cases like ".5"` \
            -e 's/^-\./-0./'      `# add "0" for cases like "-.5"`\
            -e 's/0*$//;s/\.$//';  # remove trailing zeros
    else
        printf "$result";
    fi;
    printf "\n";
}

# Create a new directory and enter it
function mkd() {
    mkdir -p "$@" && cd "$@";
}

# Change working directory to the top-most Finder window location
function cdf() { # short for `cdfinder`
    cd "$(osascript -e 'tell app "Finder" to POSIX path of (insertion location as alias)')";
}

# Create a .tar.gz archive, using `zopfli`, `pigz` or `gzip` for compression
function targz() {
    local tmpFile="${@%/}.tar";
    tar -cvf "${tmpFile}" --exclude=".DS_Store" "${@}" || return 1;

    size=$(
        stat -f"%z" "${tmpFile}" 2> /dev/null; # OS X `stat`
        stat -c"%s" "${tmpFile}" 2> /dev/null # GNU `stat`
    );

    local cmd="";
    if (( size < 52428800 )) && hash zopfli 2> /dev/null; then
        # the .tar file is smaller than 50 MB and Zopfli is available; use it
        cmd="zopfli";
    else
        if hash pigz 2> /dev/null; then
            cmd="pigz";
        else
            cmd="gzip";
        fi;
    fi;

    echo "Compressing .tar using \`${cmd}\`…";
    "${cmd}" -v "${tmpFile}" || return 1;
    [ -f "${tmpFile}" ] && rm "${tmpFile}";
    echo "${tmpFile}.gz created successfully.";
}

# Determine size of a file or total size of a directory
function fs() {
    if du -b /dev/null > /dev/null 2>&1; then
        local arg=-sbh;
    else
        local arg=-sh;
    fi
    if [[ -n "$@" ]]; then
        du $arg -- "$@";
    else
        du $arg .[^.]* *;
    fi;
}

# Use Git’s colored diff when available
hash git &>/dev/null;
if [ $? -eq 0 ]; then
    function diff() {
        git diff --no-index --color-words "$@";
    }
fi;

# Create a data URL from a file
function dataurl() {
    local mimeType=$(file -b --mime-type "$1");
    if [[ $mimeType == text/* ]]; then
        mimeType="${mimeType};charset=utf-8";
    fi
    echo "data:${mimeType};base64,$(openssl base64 -in "$1" | tr -d '\n')";
}

# Create a git.io short URL
function gitio() {
    if [ -z "${1}" -o -z "${2}" ]; then
        echo "Usage: \`gitio slug url\`";
        return 1;
    fi;
    curl -i http://git.io/ -F "url=${2}" -F "code=${1}";
}

# Start an HTTP server from a directory, optionally specifying the port
function server() {
    local port="${1:-8000}";
    sleep 1 && open "http://localhost:${port}/" &
    # Set the default Content-Type to `text/plain` instead of `application/octet-stream`
    # And serve everything as UTF-8 (although not technically correct, this doesn’t break anything for binary files)
    python -c $'import SimpleHTTPServer;\nmap = SimpleHTTPServer.SimpleHTTPRequestHandler.extensions_map;\nmap[""] = "text/plain";\nfor key, value in map.items():\n\tmap[key] = value + ";charset=UTF-8";\nSimpleHTTPServer.test();' "$port";
}

# Start a PHP server from a directory, optionally specifying the port
# (Requires PHP 5.4.0+.)
function phpserver() {
    local port="${1:-4000}";
    local ip=$(ipconfig getifaddr en1);
    sleep 1 && open "http://${ip}:${port}/" &
    php -S "${ip}:${port}";
}

# Compare original and gzipped file size
function gz() {
    local origsize=$(wc -c < "$1");
  origsize=$(( origsize / 1024 ));
    local gzipsize=$(gzip -c "$1" | wc -c);
  gzipsize=$(( gzipsize / 1024 ));
    local ratio=$(echo "$gzipsize * 100 / $origsize" | bc -l);
    printf "original size: %d KB\n" "$origsize";
    printf "gzipped  size: %d KB (%2.2f%%)\n" "$gzipsize" "$ratio";
}

# Syntax-highlight JSON strings or files
# Usage: `json '{"foo":42}'` or `echo '{"foo":42}' | json`
function json() {
    if [ -t 0 ]; then # argument
        python -mjson.tool <<< "$*" | pygmentize -l javascript;
    else # pipe
        python -mjson.tool | pygmentize -l javascript;
    fi;
}

# Run `dig` and display the most useful info
function digga() {
    dig +nocmd "$1" any +multiline +noall +answer;
}

# UTF-8-encode a string of Unicode symbols
function escape() {
    printf "\\\x%s" $(printf "$@" | xxd -p -c1 -u);
    # print a newline unless we’re piping the output to another program
    if [ -t 1 ]; then
        echo ""; # newline
    fi;
}

# Decode \x{ABCD}-style Unicode escape sequences
function unidecode() {
    perl -e "binmode(STDOUT, ':utf8'); print \"$@\"";
    # print a newline unless we’re piping the output to another program
    if [ -t 1 ]; then
        echo ""; # newline
    fi;
}

# Get a character’s Unicode code point
function codepoint() {
    perl -e "use utf8; print sprintf('U+%04X', ord(\"$@\"))";
    # print a newline unless we’re piping the output to another program
    if [ -t 1 ]; then
        echo ""; # newline
    fi;
}

# Show all the names (CNs and SANs) listed in the SSL certificate
# for a given domain
function getcertnames() {
    if [ -z "${1}" ]; then
        echo "ERROR: No domain specified.";
        return 1;
    fi;

    local domain="${1}";
    echo "Testing ${domain}…";
    echo ""; # newline

    local tmp=$(echo -e "GET / HTTP/1.0\nEOT" \
        | openssl s_client -connect "${domain}:443" -servername "${domain}" 2>&1);

    if [[ "${tmp}" = *"-----BEGIN CERTIFICATE-----"* ]]; then
        local certText=$(echo "${tmp}" \
            | openssl x509 -text -certopt "no_aux, no_header, no_issuer, no_pubkey, \
            no_serial, no_sigdump, no_signame, no_validity, no_version");
        echo "Common Name:";
        echo ""; # newline
        echo "${certText}" | grep "Subject:" | sed -e "s/^.*CN=//" | sed -e "s/\/emailAddress=.*//";
        echo ""; # newline
        echo "Subject Alternative Name(s):";
        echo ""; # newline
        echo "${certText}" | grep -A 1 "Subject Alternative Name:" \
            | sed -e "2s/DNS://g" -e "s/ //g" | tr "," "\n" | tail -n +2;
        return 0;
    else
        echo "ERROR: Certificate not found.";
        return 1;
    fi;
}

# `s` with no arguments opens the current directory in Sublime Text, otherwise
# opens the given location
function s() {
    if [ $# -eq 0 ]; then
        subl .;
    else
        subl "$@";
    fi;
}

# `a` with no arguments opens the current directory in Atom Editor, otherwise
# opens the given location
function a() {
    if [ $# -eq 0 ]; then
        atom .;
    else
        atom "$@";
    fi;
}

# `v` with no arguments opens the current directory in Vim, otherwise opens the
# given location
function v() {
    if [ $# -eq 0 ]; then
        vim .;
    else
        vim "$@";
    fi;
}

# `o` with no arguments opens the current directory, otherwise opens the given
# location
function o() {
    if [ $# -eq 0 ]; then
        open .;
    else
        open "$@";
    fi;
}

# `tre` is a shorthand for `tree` with hidden files and color enabled, ignoring
# the `.git` directory, listing directories first. The output gets piped into
# `less` with options to preserve color and line numbers, unless the output is
# small enough for one screen.
function tre() {
    tree -aC -I '.git|node_modules|bower_components' --dirsfirst "$@" | less -FRNX;
}





# shell fuctions --------------------------------------------------------
function changelogs(){
  git log $1..HEAD --pretty=format:'- %s'
}

# custom build commands ---
function build-theme(){
  DIRNAME=${PWD};
  FOLDERNAME=${PWD##*/};
  if [ -d ~/Desktop/$FOLDERNAME ]; then

    if [ "$1" == "-i" ]; then
      echo "Build folder already exists!";
      rm -rf ~/Desktop/$FOLDERNAME;
      rm -rf ~/Desktop/$FOLDERNAME.zip;
      echo "Previous build folder removed.";
    else
      echo "Build folder already exists!";
      return 0;
    fi;

  fi;
  rsync -av --exclude='.sass-cache' --exclude='_devDependencies' --exclude='node_modules' --exclude='.git' --exclude='css/sass' --exclude='css/sass-output' $DIRNAME/ ~/Desktop/$FOLDERNAME;

  echo "Building started ..";
  cd ~/Desktop/$FOLDERNAME;
  echo "Project cloned ..";
  find . -name '*.DS_Store' -type f -delete;
  echo ".DS_Store files cleared ..";
  rm -rf .*;
  rm -rf languages/fa_IR.po;
  rm -rf languages/fa_IR.mo;
  rm -rf css/rtl.css;
  rm -rf *.json;
  rm -rf Gruntfile.js;

  echo "built sucessfully done!";
  cd ~/Desktop;
  zip -r $FOLDERNAME.zip $FOLDERNAME;
  echo $FOLDERNAME.zip created sucessfully!;
  cd $DIRNAME
}

function build-git(){
  DIRNAME=${PWD};
  FOLDERNAME=${PWD##*/};
  if [ -d ~/Desktop/$FOLDERNAME ]; then
    if [ "$1" == "-i" ]; then
      echo "Build folder already exists!";
      rm -rf ~/Desktop/$FOLDERNAME;
      rm -rf ~/Desktop/$FOLDERNAME.zip;
      echo "Previous build folder removed.";
    else
      echo "Build folder already exists!";
      return 0;
    fi;
  fi;
  if [ -d ~/Desktop/$FOLDERNAME-installable.zip ]; then
    if [ "$1" == "-i" ]; then
      echo "Build archive file already exists!";
      rm -rf ~/Desktop/$FOLDERNAME-installable.zip;
      echo "Previous build archive file removed.";
    fi;
  fi;
  cp -r $DIRNAME ~/Desktop/$FOLDERNAME;
  echo "Building started ..";
  cd ~/Desktop/$FOLDERNAME;
  echo "Project cloned ..";
  find . -name '*.DS_Store' -type f -delete;
  echo ".DS_Store files cleared ..";
  rm -rf .git;
  echo "Git history cleared ..";
  rm -f deploy.sh;
  echo "deploy.sh file removed ..";

  cd ~/Desktop;
  if [ "$1" == "-i" ]; then
    echo "Creating archive file ..";
    zip -r $FOLDERNAME-installable.zip $FOLDERNAME;
    echo $FOLDERNAME-installable.zip created sucessfully!;
    rm -rf $FOLDERNAME;
  else
    echo "Creating archive file ..";
    zip -r $FOLDERNAME.zip $FOLDERNAME;
    echo $FOLDERNAME.zip created sucessfully!;
  fi;
  echo "built sucessfully done!";
  cd $DIRNAME
}


# Open prject if exists
function pro(){

    if [ -d "/LAB/projects/wp/plugins/$1" ]; then
        cd "/LAB/projects/wp/plugins/$1";
        if [ "$2" == "o" ]; then
            open .;
        fi;
        if [ "$2" == "s" ]; then
            open .;
        fi;
        return 0;
    fi;

    if [ -d "/LAB/projects/wp/themes/$1" ]; then
        cd "/LAB/projects/wp/themes/$1";
        if [ "$2" == "o" ]; then
            open .;
        fi;
        if [ "$2" == "s" ]; then
            open .;
        fi;
        return 0;
    fi;

    if [ -d "/LAB/projects/$1" ]; then
        cd "/LAB/projects/$1";
        if [ "$2" == "o" ]; then
            open .;
        fi;
        if [ "$2" == "s" ]; then
            open .;
        fi;
        return 0;
    fi;
}

function plugin(){
  plugins && cd "$1";

  if [ "$2" == "--o" ]; then
    open .;
  fi;

  if [ "$2" == "subl" ]; then
    subl .;
  fi;
}

function theme(){
  themes && cd "$1";

  if [ "$2" == "--o" ]; then
    open .;
  fi;

  if [ "$2" == "subl" ]; then
    subl .;
  fi;
}


# Create and switch to <new directory>
md ()
{
    if [ "$1" == "" ]; then
        echo "md <directory-name>";
    else
        if [ ! -d $1 ]; then
            mkdir $1;
            cd $1;
        else
            echo "$1 directory exists";
        fi;
    fi
}

function tab() {
  about 'opens a new terminal tab'
  group 'osx'

  osascript 2>/dev/null <<EOF
    tell application "System Events"
      tell process "Terminal" to keystroke "t" using command down
    end
    tell application "Terminal"
      activate
      do script with command " cd \"$PWD\"; $*" in window 1
    end tell
EOF
}

extract () {
  if [ $# -ne 1 ]
  then
    echo "Error: No file specified."
    return 1
  fi
        if [ -f $1 ] ; then
                case $1 in
                        *.tar.bz2) tar xvjf $1   ;;
                        *.tar.gz)  tar xvzf $1   ;;
                        *.bz2)     bunzip2 $1    ;;
                        *.rar)     unrar x $1    ;;
                        *.gz)      gunzip $1     ;;
                        *.tar)     tar xvf $1    ;;
                        *.tbz2)    tar xvjf $1   ;;
                        *.tgz)     tar xvzf $1   ;;
                        *.zip)     unzip $1      ;;
                        *.Z)       uncompress $1 ;;
                        *.7z)      7z x $1       ;;
                        *)         echo "'$1' cannot be extracted via extract" ;;
                esac
        else
                echo "'$1' is not a valid file"
        fi
}



z() {
 local datafile="$HOME/.z"
 if [ "$1" = "--add" ]; then
  # add
  shift
  # $HOME isn't worth matching
  [ "$*" = "$HOME" ] && return
  awk -v p="$*" -v t="$(date +%s)" -F"|" '
   BEGIN { rank[p] = 1; time[p] = t }
   $2 >= 1 {
    if( $1 == p ) {
     rank[$1] = $2 + 1
     time[$1] = t
    } else {
     rank[$1] = $2
     time[$1] = $3
    }
    count += $2
   }
   END {
    if( count > 1000 ) {
     for( i in rank ) print i "|" 0.9*rank[i] "|" time[i] # aging
    } else for( i in rank ) print i "|" rank[i] "|" time[i]
   }
  ' "$datafile" 2>/dev/null > "$datafile.tmp"
  mv -f "$datafile.tmp" "$datafile"
 elif [ "$1" = "--complete" ]; then
  # tab completion
  awk -v q="$2" -F"|" '
   BEGIN {
    if( q == tolower(q) ) nocase = 1
    split(substr(q,3),fnd," ")
   }
   {
    if( system("test -d \"" $1 "\"") ) next
    if( nocase ) {
     for( i in fnd ) tolower($1) !~ tolower(fnd[i]) && $1 = ""
     if( $1 ) print $1
    } else {
     for( i in fnd ) $1 !~ fnd[i] && $1 = ""
     if( $1 ) print $1
    }
   }
  ' "$datafile" 2>/dev/null
 else
  # list/go
  while [ "$1" ]; do case "$1" in
   -h) echo "z [-h][-l][-r][-t] args" >&2; return;;
   -l) local list=1;;
   -r) local typ="rank";;
   -t) local typ="recent";;
   --) while [ "$1" ]; do shift; local fnd="$fnd $1";done;;
    *) local fnd="$fnd $1";;
  esac; local last=$1; shift; done
  [ "$fnd" ] || local list=1
  # if we hit enter on a completion just go there
  [ -d "$last" ] && cd "$last" && return
  [ -f "$datafile" ] || return
  local cd="$(awk -v t="$(date +%s)" -v list="$list" -v typ="$typ" -v q="$fnd" -v tmpfl="$datafile.tmp" -F"|" '
   function frecent(rank, time) {
    dx = t-time
    if( dx < 3600 ) return rank*4
    if( dx < 86400 ) return rank*2
    if( dx < 604800 ) return rank/2
    return rank/4
   }
   function output(files, toopen, override) {
    if( list ) {
     if( typ == "recent" ) {
      cmd = "sort -nr >&2"
     } else cmd = "sort -n >&2"
     for( i in files ) if( files[i] ) printf "%-10s %s\n", files[i], i | cmd
     if( override ) printf "%-10s %s\n", "common:", override > "/dev/stderr"
    } else {
     if( override ) toopen = override
     print toopen
    }
   }
   function common(matches, fnd, nc) {
    for( i in matches ) {
     if( matches[i] && (!short || length(i) < length(short)) ) short = i
    }
    if( short == "/" ) return
    for( i in matches ) if( matches[i] && i !~ short ) x = 1
    if( x ) return
    if( nc ) {
     for( i in fnd ) if( tolower(short) !~ tolower(fnd[i]) ) x = 1
    } else for( i in fnd ) if( short !~ fnd[i] ) x = 1
    if( !x ) return short
   }
   BEGIN { split(q, a, " ") }
   {
    if( system("test -d \"" $1 "\"") ) next
    print $0 >> tmpfl
    if( typ == "rank" ) {
     f = $2
    } else if( typ == "recent" ) {
     f = t-$3
    } else f = frecent($2, $3)
    wcase[$1] = nocase[$1] = f
    for( i in a ) {
     if( $1 !~ a[i] ) delete wcase[$1]
     if( tolower($1) !~ tolower(a[i]) ) delete nocase[$1]
    }
    if( wcase[$1] > oldf ) {
     cx = $1
     oldf = wcase[$1]
    } else if( nocase[$1] > noldf ) {
     ncx = $1
     noldf = nocase[$1]
    }
   }
   END {
    if( cx ) {
     output(wcase, cx, common(wcase, a, 0))
    } else if( ncx ) output(nocase, ncx, common(nocase, a, 1))
   }
  ' "$datafile")"
  if [ $? -gt 0 ]; then
   rm -f "$datafile.tmp"
  else
   mv -f "$datafile.tmp" "$datafile"
   [ "$cd" ] && cd "$cd"
  fi
 fi
}

gclone ()
{
    if [ "$1" == "" ]; then
        echo "gclone <git-repo-url>";
    else
        REPONAME=$(basename $1 .git);

        if [ ! -d $REPONAME ]; then
            echo "cloning repo .."
            git clone $1;
            cd $REPONAME;

        else
            echo "[$REPONAME] already exists. Switched to REPO.";
            cd $REPONAME;

            read -p "Check whether local and remote are in sync?[ y(diff), f(fetch), p(pull) ]" -n 1 -r
            echo    # (optional) move to a new line
            if [[ $REPLY =~ ^[YyDd]$ ]]; then
              git diff origin/master;
              git diff origin/develop;
            fi;
            if [[ $REPLY =~ ^[Ff]$ ]]; then
              git fetch --all;
            fi;
            if [[ $REPLY =~ ^[Pp]$ ]]; then
              git pull --all;
            fi;

        fi;
    fi;
}


function strip_diff_leading_symbols(){
   color_code_regex="(\x1B\[([0-9]{1,2}(;[0-9]{1,2})?)?[m|K])"

   # simplify the unified patch diff header
   sed -r "s/^($color_code_regex)diff --git .*$//g" | \
       sed -r "s/^($color_code_regex)index .*$/\n\1$(rule)/g" | \
       sed -r "s/^($color_code_regex)\+\+\+(.*)$/\1+++\5\n\1$(rule)\x1B\[m/g" |\

   # actually strips the leading symbols
       sed -r "s/^($color_code_regex)[\+\-]/\1 /g"
}

## Print a horizontal rule
rule () {
   printf "%$(tput cols)s\n"|tr " " "─"}}
}
